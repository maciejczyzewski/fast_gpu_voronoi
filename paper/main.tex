\documentclass[format=acmsmall,screen,review,authordraft,nonacm]{acmart}
%\documentclass[format=acmsmall,screen,review,authordraft]{acmart}
%\documentclass{article}

% FIXME: https://arxiv.org/pdf/1709.06182.pdf
%        maja ladny template / chyba dziabne
%        albo ten z brytyjskiego sem6
%      https://github.com/borisveytsman/acmart

% FIXME: https://github.com/google-research/arxiv-latex-cleaner

% XXX: (mental anchor / looped / 3h) ->  UNDADASEA + LANE 8
%      https://www.youtube.com/watch?v=n_LcVqqHSY8
%      https://www.youtube.com/watch?v=vpeljtzB1a4

% kollektiv
% https://www.youtube.com/watch?v=E8g5YrDXg2k
% go with the flow
% https://www.youtube.com/watch?v=DcHKOC64KnE
% private party project
% https://www.youtube.com/watch?v=ckKi01gqW7A&t=878s
% royal blood
% https://www.youtube.com/watch?v=sbx95gBb5HM
% i don't want to sleep
% https://www.youtube.com/watch?v=3oBCu9zywzE
% hehe
% https://www.youtube.com/watch?v=Dii8ZVtR9Tc&t=18s
% gary clark jr
% https://www.youtube.com/watch?v=iAXZmaqknQU

%\usepackage{arxiv}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
%\usepackage[hidelinks]{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{lipsum}		% Can be removed after putting your text content
\usepackage{graphicx}
\usepackage{float}

\usepackage{url}
\newcommand\longvar[1]{\mathchardef\UrlBreakPenalty=100
\mathchardef\UrlBigBreakPenalty=100\url{#1}}

%%% BONUS %%%
%\usepackage[table]{xcolor}  % for colors (like `red`)
\usepackage[normalem]{ulem} % for underline
\usepackage{booktabs}       % for better table
\usepackage{bm}             % for special table cell (`cellcolor`)
\usepackage{hhline,soul}    % for `hl` command (highlight text)
\usepackage{amsmath}        % for multi-line math
\usepackage[bottom]{footmisc}% for footnotes

\usepackage{diagbox} % TABLE MASTERS - section
\usepackage{tabularx, booktabs}
\newcolumntype{L}{>{\raggedright\footnotesize}m{5.75cm}}
\renewcommand{\arraystretch}{1.2}
%%%%%%%%%%%%%

\usepackage{listings}
\lstset{
  language=Python,
  basicstyle=\footnotesize\ttfamily,
  captionpos=b,
  breaklines=false,
  escapeinside={(*}{*)},
  keywordstyle=\color{blue},
  tabsize=2,
  showspaces=false,
  breakatwhitespace=true,
  showstringspaces=false,
  columns=fullflexible,
  %numbers=left,
  numbersep=3pt,
  showtabs=false,
  %numberstyle=\scriptsize\ttfamily\color{mygray},
  morekeywords={string,foreach,var,async,await,lock},
  frame=TB
}

\newcommand{\ourjfasingle}{JFAStar}
\newcommand{\ourjfa}{Vorotron} % okJFAuto

% \title{A survey of \emph{jump flooding algorithm} applied to Voronoi}
% \emph{\ourjfa}: Evolving Fast GPU Algorithm for
% Voronoi Diagram and Distance Transform in O(1) from JFA using AutoML

% https://capitalizemytitle.com/
\title{Lord Vorotron: Finding the Best JFA Variant for the Coming Winter} % $\approx$

\author{Maciej A. Czyzewski}
\email{maciejanthonyczyzewski@gmail.com}
\affiliation{%
 \department{Institute of Computing Science}
 \institution{Poznan University of Technology}
 \city{Poznan}
 \country{Poland}}

\author{Kamil Piechowiak}
\email{kamil.cams@gmail.com}
\affiliation{%
 \department{Institute of Computing Science}
 \institution{Poznan University of Technology}
 \city{Poznan}
 \country{Poland}}

% \author{
%   Maciej A.~Czyzewski\\
%   Institute of Computing Science\\
%   Poznan University of Technology\\
%   Piotrowo 2, 60-965 Poznan, Poland\\
%   \texttt{maciejanthonyczyzewski@gmail.com} \\
%   \And
%   Kamil~Piechowiak\\
%   Institute of Computing Science\\
%   Poznan University of Technology\\
%   Piotrowo 2, 60-965 Poznan, Poland\\
%   \texttt{kamil.cams@gmail.com} \\
% }

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \hl{\textbf{UWAGA!} Przenioslem fragmenty ze starego szkicu, teraz jednak czuje ze
% powinnien byc to takie ogolne podsumowanie wszystkich mozliwych wariantow JFA - i
% w jakich przypadkach sie sprawdzaja. A tak przyokazji nasza wersja z szumem+trikami
% ktora dobrze dziala, no i dodatek taki ze mozna teraz zrobic sobie ensembla (a
% nie jako glowny cel tej pracy). Dlatego wszystko co ponizej to praktycznie
% random/bardzo mocny szkic. Wykresy to wizualizacja smaku.}
% \newline

\hl{\textbf{UWAGA}: wymyslic prawidlowa nazwe pracy + poprawic zlozonosci +
opisac dwa algorytmy}

\begin{abstract}
This paper studies a practical usage of machine learning (AutoML) to automate
research towards discovering efficient Voronoi Diagram and Distance Transform
algorithms.  As the baseline we used the Jump Flooding Algorithm (JFA) - by
finding new mutations which works best for specific data, and then ensembling
them into one, we create new state-of-the-art algorithm in this field named
\textbf{\ourjfa} \hspace{0.01cm} with time complexity \textcolor{red}{$\approx$O(1)} and
work complexity \textcolor{red}{$\approx$O(N)}.
The algorithm is faster and produces more accurate approximations. It could be
extended into 3D space in a slice-by-slice manner.  We started from the
assumption that JFA has potential for improvement - some benefits can be
observed for specific data by adding random noise and adjusting the step size in
JFA.  This showed us that, AutoML could examine this space, and find the best
possible algorithm in each case.  In the further part of the work, we discuss
the results, compare the variants and ensemble for creating the final algorithm.
\end{abstract}

% http://dl.acm.org/ccs.cfm

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10010147.10010371</concept_id>
<concept_desc>Computing methodologies~Computer graphics</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003752.10010061</concept_id>
<concept_desc>Theory of computation~Randomness, geometry and discrete structures</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10010147.10010169</concept_id>
<concept_desc>Computing methodologies~Parallel computing methodologies</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003752.10003809.10010031</concept_id>
<concept_desc>Theory of computation~Data structures design and analysis</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computing methodologies~Computer graphics}
\ccsdesc[300]{Theory of computation~Randomness, geometry and discrete structures}
\ccsdesc[500]{Computing methodologies~Parallel computing methodologies}
\ccsdesc[500]{Theory of computation~Data structures design and analysis}

\keywords{Voronoi Diagram, Distance Transform, Code Generation}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% FIXME: na wypadek zmiany tytulu w przyszlsoci!!!!!!!!!! ;-)
This paper\footnote{the original title for this paper was ``Lord Vorotron:
Finding the Best JFA Variant for the Coming Winter''} studies a practical usage of machine learning to automate research
towards discovering efficient Distance Transform algorithms (utilizing technique known as AutoML).
Thus, by finding mutations which works best for specific data, and then ensembling them into
one, we create new state-of-the-art algorithm in this field named \uline{\ourjfa \hspace{0.01cm} with
time complexity $\approx$O(1) and work complexity $\approx$O(N).}

Notable contribution to the quick algorithm that makes Distance Transform (DT)
using graphics hardware includes \citep{hoff1999fast} that creates a cone for
each input (point/seed) and renders those cones to obtain the Voronoi diagram as the lower envelope of these cones.
\cite{fischer2006fast} use planes tangent to a paraboloid and thus avoid the errors caused by the tessellation of the cones.
Unfortunately, the drawback of this approach is the significant amount of computation and the implementation complexity.

Jump flooding algorithm (JFA)\footnote{a novel pattern of
communication} is an interesting way to utilize the graphics processing unit to
efficiently compute Voronoi diagrams and distance transforms
\cite{rong2006jump}. This method is faster and produces more accurate results
\cite{rong2007variants}, and furthermore, it could be extended into 3D space in a slice-by-slice manner.
This is more effective than the previous research carried out by
\citep{sud2006interactive}, because the speed of JFA is almost independent to the number of seeds \cite{rong2007variants}.

Based on this research and findings, several efficient GPU-based algorithms which are either
work optimal or time optimal have been proposed including
SKW \cite{schneider2009gpu}, PBA \cite{cao2010parallel}, FastGPU \cite{de2017fast}, Honda's algorithm \cite{honda2017simple} and
WTO \cite{manduhu2019work}.

The main question that needs to be addressed now is whether JFA has potential
for improvement. We found some benefits for specific data by adding random noise
and adjusting the phase size in JFA. Therefore, this shows that, AutoML could examine this
unknown space, and find the best possible algorithm in each case.

For convenience, this work focus on the Voronoi diagram only - because this problem can be translated to DT \cite{rong2006jump}.
The algorithm would be an approximation of the output, thus we suggest using WTO
\cite{manduhu2019work} for exact DT (EDT). The major contributions of this paper are thus:

\begin{enumerate}
	\item Presenting new state-of-the-art variants of algorithm for Voronoi
		Diagram and Distance Transform: \newline
		\textbf{\ourjfasingle} - (Multi-domain) single best variant;
		\textbf{\ourjfa} - (Specific-domain) ensemble of weak variants; and
	\item Analyzing all possible variants of JFA: comparing error and speedup
		relative to bruteforce method
%\item Proposing, for an input set of seeds in a 2D grid, the first
%parallel algorithm in GPU to compute in constant time (i.e.
%independent of the number of seeds) a highly accurate
%Voronoi diagram and distance transform.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Several efficient GPU-based algorithms which are either
work optimal or time optimal have been proposed including
JFA \cite{rong2006jump}, SKW \cite{schneider2009gpu},
PBA \cite{cao2010parallel}, FastGPU \cite{de2017fast}, Honda's algorithm \cite{honda2017simple} and
WTO \cite{manduhu2019work}.

\begin{table}[H] \centering
\begin{tabular}{@{}lllll@{}}
\toprule
\textbf{Reference}                & \textbf{Algorithm}    & \textbf{Exactness}
	& \textbf{Time}         & \textbf{Work}         \\ \midrule
\citep{de2017fast}       & FastGPU      & Exact       & $O(n^3/p)$   & -            \\
\citep{cao2010parallel}  & PBA          & Exact       & $O(n)$       & $O(mN)$      \\
\citep{honda2017simple}  & based on SKW & Exact       & $O(n)$       & $O(N)$       \\
\citep{manduhu2019work}  & WTO          & \cellcolor{blue!25}\textbf{Exact}&
	\cellcolor{blue!25}$\mathbf{O(\log n)}$  & $O(N)$       \\
\citep{schneider2009gpu} & SKW          & Approximate & $O(n)$       & $O(N)$       \\
\citep{rong2006jump}     & JFA          & Approximate & $O(\log n)$  & $O(N\log n)$ \\ \bottomrule
In this paper            & \ourjfasingle&
	\cellcolor{blue!25}\textbf{Approximate} &
	\cellcolor{blue!25}$\sim$$\mathbf{O(\log^{\ast} n)}$ & $\sim$$O(N)$ \\
                         & \ourjfa      &
	\cellcolor{blue!25}\textbf{Approximate} &
	\cellcolor{blue!25}$\sim$$\mathbf{O(1)}$ & $\sim$$O(N)$ \\
\bottomrule
\end{tabular}
\vspace{1em}
\caption{Different GPU algorithms for computing EDT}
\end{table}

\subsection{Jump Flooding} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hl{redukcja i bridge pomiedzy intro (usunac subsection)}

co to jest jump flooding? tak naprawde to nie jest algorytm do voronoi-a tylko
pattern komunikacyjny w programowaniu rownoleglym - swojej pracy doktorskiej
autor tej techniki podaje wiele zastosowan jednak w swoich badaniach ogranicza
sie do Voronoi-a. glownym pytaniem roznych takich patternow jest ile potrzebnych
jest rund/operacji komunikacji aby zagwarantowac aby dana informacja zostanie
dostarczona. akurat w voronoi-u wiele komorek jest lokalna w skali calego
przykladu - wiec JFA ktora gwarantuje dostarczenie informacji globalnie do
kazdego punktu - wykonuje pewne niepotrzebne operacje.  szybkosc i zajetosc
pamieciowa JFA jest satysfakcujaca, jednak proste modyfikacje pokazuja ze
algorytm ten wykonuje sie szybciej w pewnych przypadkach (i to typowych).
dlatego naturalnym pytanie powinno byc w jakich oraz jakie modyfikacje wplywaja
na szybkosc dzialania.

\subsection{AutoML} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hl{przeniesc do Proposed Method}

\url{https://arxiv.org/pdf/1801.09373.pdf}
\url{https://arxiv.org/pdf/1804.10120.pdf}
\url{https://arxiv.org/pdf/1703.06353.pdf}

okay przenioslem - dodac prace co tez tak szuka algosow

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Proposed Method} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hl{przepisac ten szkic bo jezyk sie placzy}

JFA opiera sie na tym ze infomacja jest przekazywana ??????.  Przekazanie odbywa
sie w log(n) krokach. Wiec przeprowadzilismy krotki eksperyment applyujac losowy
szum na wejsciowa masce. Okazalosie sie ze ilosc potrzebnych krokow spadla -
powstaly losowe shortcuty.  Co oznacza ze powinny istniec inne "mutacje"
algorytmow lepsze w pewnych okreslonych przypadkach.  Wiec szukanie najszybszego
algorytmu bedzie nastepujace:

\begin{itemize}
\item Wymyslenie wszystkich mozliwych wariantow JFA
\item Mutacje i zapisanie najlepszych wersji dla danej domeny
\item Ensemblacja algorytmow tak aby wybierac najlepszy variant dla danej domeny
\end{itemize}

\subsection{Domain Space} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hl{okay, zupelnie inaczej tutaj podejsc, opisac jakie sa przypadki i jakie sa
spotykane}

jakie domeny i dlaczego (i jak dzialaly gen\_uniform, \hl{gen\_polar, gen\_grid})

KWADRAT TUTAJ????????? (komentarz latex)


\begin{table}[H] \centering
\begin{tabular}{@{}l|ccc@{}}
\toprule
\hspace*{0.175cm}\diagbox{\textbf{Density}}{\textbf{Shape}}
                         & Small (32-128)    & Medium (256-448)   & Large (512-1536)  \\
\midrule
Low ($\rho$=0.00005-0.001)    & Bruteforce           & Bruteforce        & JFA       \\
High ($\rho$=0.01-0.1)        & JFA           & JFA        & JFA       \\
\bottomrule
\end{tabular}
\vspace{1em}
\caption{State-of-the-art for specific domains (before our work).}
\end{table}

% # kwadrat
% #                   small          medium       big
% #    low den.        ?                ?         JFA
% #    high den.       ?                ?          ?

% # [music]
% # https://www.youtube.com/watch?v=78oIolvjIsw

\subsection{Search Space} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hl{\textbf{UWAGA}: opisac ze szukamy 4 podprzestrzenie w turach! (moze tez o
nowym wzorku ktory szuka tylko prawidlowych}

\hl{bridge z score function gdziekolwiek to bedzie}
\hl{obliczyc ile jest aktulanie wersji algosow np. czy jest to juz 2do14 jak
mamy 3xreal w wielomianie AKTUALNIE JEST okolo 7,200?}

jakie modyfikacje, na to osobna sekcja? wiec co tu napisac
chyba tylko o zlozonosci problemu i ze kod jest skladany i testowany a niektore
wersje sa pomijane zgodnie z dzialaniem gp\_minimize (Bayesian optimization
using Gaussian Processes).

w naszym wypadku zdefiniowalismy pewien zbior variantow pewnych czesci
algorytmu (Search Space), modul testujacy dana mutacje/wariant - sklada kod kernela a pozniej go weryfikuje na naszej Domain Space.

\subsection{Score Function} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hl{JEST PROBLEM - zdazaja sie warianty ktore 0zeruja rzadkie i sa bardzo
szybkie na duzy matrycach - trzeba do ponownie zbalansowac}
\hl{roznica w pikselach pomiedzy bruteforce a algorytmem - napisac o tym / tez
ze to wszystko to ilorazy do bruteforce}

dla voronoi-a interesuja nas 2 parametry Error oraz Szybkosc, aby wyniki byly
wiarygodne porownujemy je z bruteforcem (a wiec bedzie to iloraz).
aby ocenic dana mutacje musimy przypisac jakis Score danej wersji, wiec uzylismy
wzor ponizej

\begin{align}
	S(x,y) = max\{0, \sqrt{x} \cdot (100-y^{2})\}, \\
0 \leq y \leq 100, 0 < x
\end{align}

ktory kaze za zbyt wysokie errory, dajac zerowy wynik - skladnik przy y rosnie
szybciej niz x wiec gdy przekroczy 100 da nam ujemny wynik - czyli 0.

\subsection{Optimizer} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hl{opisac dwie osobne taktyki optymalizacji dla best single vs. ensemble}

mozemy napisac ze korzystalismy z forest/gp minimize, ale tez wspomniec ze aby
miec najlepszy best single to trzeba bylo optymalizowac rownoczesnie cala
przestrzen (od malych do duzych, gestych po rzadkie), a zeby miec najlepszego
Vorotrona - czyli ensembla to trzeba bylo dla kazdej domeny z optymalizowac a
pozniej jedynie zrobic balancera!!!!!!!!!!!!

\hl{trzeba to przeszukiwac tak aby nie sfiksowal na zadanych parametrach - bo
niechcacy ocenia na poczatku ze szum/dual jest nie fajny i pozniej go juz nie
rozwaza}

\subsection{Ensemble} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hl{mozna zapisac tabele dla kazdej domeny (shape) / i zrobic przewidywania
parametrow (slownik wariantu) - bo dla malych oplacalne sa Circle6 a dla
wiekszych Circle12 i tak dalej - jak to zrobic?}

patrzac na rezultaty mozemy znalesc jaki algorytm najlepiej sprawdza sie w
zadanej domenie. np. widac ze dla malej ilosci seedow (malo gestych przypadkow,
ktore maja mala powierzchnie) oplaca sie uzyc bruteforce. Dla kolejnych
wiekszych przypadkow innych wariantow JFA. Jak wybrac algorytm? Kazdy przypadek ma `shape` oraz `num` wiec mozna na CPU wysemplowac
pare punktow albo odrazu obliczyc gestosc i wybrac odpowiedni algorytm.
To takich ensemblacji najlepiej sprawdzi sie drzewo decyzyjne (moze byc boostowane).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Variants} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hl{ZROBIC LADNE RYSUNECZKI w Google Slides - eksport to pdf!}

To compute the Voronoi diagram for a 2D grid of size n×n
with a given set of seeds at some grid points, we are interested to
propagate the content (in particular, position information) of each
seed s to each grid point so that each grid point can decide which
seed is its closest one.

Niektore operacje propagacji informacji sa zbedne - tylko w przypadkach
rzadkich macierzy potrzeba jest log(n) krokow aby uzyskac prawidlowy wynik.
Rozne warianty omawiane w \cite{rong2007variants} pozwalaja zredukowac blad
klasycznego JFA. Nie zostaly jednak omawiane przypadki gdzie poszczegolne
modyfikacje sa uzywane z innymi.

Dlatego w tej pracy prezentujemy dodatkowe modyfikacje ktore mozna zastosowac
aby stworzyc nowe warianty. Pewne modyfikacje sa oczywiste i wynikaja z
alternatywnego podejscia (zamiast anchoru\footnote{anchorem nazywamy metode
ktora pobiera sasiadow do przekazania informacji} kwadratowego mozna uzyc kola),
informacje mozna wstepnie rozpropagowac losowo - w nadzie ze pozwoli nam
skonczyc algorytm w mniejszej ilosci krokow.

Aby badania byly bardziej przejrzyste trzymalismy sie pewnej konfencji
nazewniczej:
$$
[\bm{anchor\_type}][\bm{anchor\_num}][\bm{anchor\_double}]\qquad-\qquad[\bm{step\_function}]\qquad+\qquad[\bm{noise}]
$$

dla przykladu \longvar{Circle11(1/3)Dual(1/4)-Factor3+Noise} ktore mozna
przeczytac jako:

\begin{flalign*}
	\text{[anchor\_type]}=Circle, \\
	\text{[anchor\_num]}=11, \\
	\text{[anchor\_number\_ratio]}=1/3, \\
	\text{[anchor\_double]}=True, \\
	\text{[anchor\_distance\_ratio]}=1/4, \\
	\text{[step\_function]}=Factor3, \\
	\text{[noise]}=True
\end{flalign*}

\subsection{Noise} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% [4 figures]      [4 figures]
% 		{\LARGE$\xrightarrow{T}$}%

\begin{figure}[H]
	\begin{minipage}{0.48\textwidth}
		\centering
		\includegraphics[width=0.23\linewidth]{../figures/mod_noise_1_in}
		\includegraphics[width=0.23\linewidth]{../figures/mod_noise_1_out}
		,
		\includegraphics[width=0.23\linewidth]{../figures/mod_noise_2_in}
		\includegraphics[width=0.23\linewidth]{../figures/mod_noise_2_out}
		\caption{Noise for 32x32}
		\label{Fig:noise}
	\end{minipage}\hfill
	\begin{minipage}{0.48\textwidth}
		\centering
		\includegraphics[width=0.23\linewidth]{../figures/mod_lnoise_v2_1_in}
		\includegraphics[width=0.23\linewidth]{../figures/mod_lnoise_v2_1_out}
		,
		\includegraphics[width=0.23\linewidth]{../figures/mod_lnoise_v2_2_in}
		\includegraphics[width=0.23\linewidth]{../figures/mod_lnoise_v2_2_out}
		\caption{Local Noise for 32x32}
		\label{Fig:lnoise}
	\end{minipage}
\end{figure}

\hl{FIXME: figure z przykladami szumu (+local) i jak to wyglada i jak wygladalo
instancja!}

Zamiast zaczynac od pustej macierzy z seed-ami poczatkowymi mozna ja losowa
uzupelnic szumem - tworzac przypadkowe short-cuty. Mozna tego dokonac osobnym
kernelem ktory zostatnie wywolany przed wykonaniem glownej czesci algorytmu.
Interpretacja jest taka ze pewne rejony ktora w JFA sa wypelnione zerami podczas
pierwszych iteracji nie podejmuja zadnych decyzji. Uzupelniajac szumem moga one
przypadkowo ustawic sie na prawidlowa wartosc i propagowac w kolejnej rundzie
najlepsza wartosc w swoim otoczeniu (zgodnie ze stepem).

\hl{dowod kamila tutaj????????????????}

\subsubsection{Local Noise} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hl{przesunieta ciezkosci??? czyli srednia z wagami poprawila? \textbf{a moze uzaleznisc
wage od rozmiaru pierwszego stepu?}}

% Mozna tez szum uzupelniac nie losowo tylko w otoczeniu. Wiec gdy w punkcie
% $(x,y)$ wylosujemy losowego seed-a o wartosci $(x_{rand}, y_{rand})$ to
% wyliczamy nowa pozycje $(x', y')$ ktora znajduje sie
% w polowie drogi w nastepujacy sposob: $x' = \frac{x+x_{rand}}{2}$, analogicznie
% dla $y'$. Dodatkowo jesli $(x', y')$ jest pusta to tez uzupelniamy to pole ta
% informacja. Nie przejmujemy sie wyscigiem w dostepie do danych. Nadpisania beda
% losowe - a szum tez.

Mozna tez szum uzupelniac nie losowo tylko w otoczeniu. Wiec gdy w punkcie
$(x,y)$ wylosujemy losowego seed-a o wartosci $(x_{rand}, y_{rand})$ to
wyliczamy nowa pozycje $(x', y')$ ktora znajduje sie
w polowie drogi w nastepujacy sposob: $x' = \frac{x+3x_{rand}}{4}$, analogicznie
dla $y'$. Dodatkowo jesli $(x', y')$ jest pusta to tez uzupelniamy to pole ta
informacja. Nie przejmujemy sie wyscigiem w dostepie do danych. Nadpisania beda
losowe - a szum tez.

\subsection{Anchor Type} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hl{losowane punkty na okregu???}

Zamiast pobierac informacje od 8 sasiadow o step size from grid points at
$(x+i, y+j)$ where $i, j \in \{-\text{step}, 0, \text{step}\}$. Mozna zastosowac
okrag - otwiera nam to nowe mozliwosci na swobodna modyfikacje ilosci punktow od
ktorych bedziemy pobierac informacje. Naturalnie wydaje sie ze mala ilosc
punktow w anchorze spowoduje wzrost bledu, a duza ilosc punktow spowoduje
zmalenie bledu.

\subsubsection{Anchor Number} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Dlatego kolejnym parametrem bedzie mozliwosc kontrolowania ilosci punktow.
Niestety nie rozwazalismy wariantu kwadratow o dowolnej ilosci punktow (poniewaz
byly by to wielokrotnosci 2x2=4, 3x3=9, 4x4=16, 5x5=25) bo i tak nie dalo by sie
wybrac uniformly tej wartosci. Dla okregu punkty sasiada $(x_i, y_i)$ byly liczone
nastepujaco:
   
$$
x_i = x + \text{step} \cdot \cos( \frac{2\pi}{\text{[anchor\_num]}} \cdot i ),
y_i = y + \text{step} \cdot \sin( \frac{2\pi}{\text{[anchor\_num]}} \cdot i )
$$

\subsection{Anchor Double} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Oprocz pojedynczego anchora, mozliwe jest uzycie podwojnej warstwy anchorow
(czyli np. male kolko i wieksze). Idea za tym stojaca to ze male kolko
wewnetrzne jest dokladne (dziala jak w JFA) - a wielkie zewnetrzne
jest skautujace lub aby poprawic error wynikajacy np. z mniejszej ilosci
$\text{anchor\_num}$ (w sumie to podobny mechanizm jak w Lookahead - wolny/szybki)

\subsubsection{Anchor Distance Ratio}

Parametr mowiacy o stosunku dlugosci step size od wewnetrzengo anchora do
zewnetrznego.

\subsubsection{Anchor Number Ratio}

Parametr mowiacy o statusnku ilosci detektorow od wewnetrznego anchora do
zewnetrznego.

\subsection{Step Function} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Gdy nasza informacja propaguje sie szybciej lub jest bardziej zageszczona
dlatego sasiedzi szybciej dostaja prawidlowa informacje - to oznacza ze mozna
skrocic ilosc round wykonania algorytmu.

Step size jak i ich ilosc mozna okreslic za pomoca 2 podstawowych parametrow:
shape and number of points - z ktorych pozniej mozemy okreslic np. srednia
gestosc. Zaimplementowalismy 2 warianty ktore sa uzaleznione jedynie od shape:
defaultowy z JFA, z JFA o podstawie 3; oraz jeden uzaleniony od shape oraz od num: logstar.
Jednak aby wygeneralizowac problem stworzylismy tez mozliwosc wygenerowania
dowolnego polynomialu.

\subsubsection{Special Polynomial}

\hl{problem z Special - on overfituje przyklady zmieniajac 5 miejsce po
przecinsku aby 2 zamienialo sie np. w 1}

Implementacja nie jest wazna - chodzi o idea zwiazania shape oraz num. Oraz
modyfikowanie wartosci, szybkosci spadku, ksztaltu (np. piloksztnego) - jakimis
parametrami. Wada tego rozwiazania jest ze trzeba optymalizowac ta funkcje na
calej dziedzinie (malej, duzej, gestej, zadkiej) - bo inaczej z overfituje ona
ilosc krokow i wiekosc stepu pod rozmiar.

\begin{lstlisting}
def mod_step_function__special(shape, num=None, config=None):
    # [EXAMPLE]
    # Special(1.51/0.92/0.92/1.08/0.42)
    # ------- A -- B -- C -- D -- X --- 

    A = config["A"]  # <1,   2>
    B = config["B"]  # <0,   1>
    C = config["C"]  # <0,   1>
    D = config["D"]  # <1,   2>
    X = config["X"]  # <0.2, 1>

    q = num / (shape[0] * shape[1])
    qm = ((shape[0] + shape[1]) / 2) * q**(1 / 2)
    S = B * qm + (1 - B) * (max(shape) / 2)
    St = math.log2(S)

    steps = []
    for i in range(1, int(X * St * 2), 1):
        f = round(1 / (D**(i**A) + i % max(1, int(C * St))), 4)
        ffm = int(f * S)
        if ffm >= 1:
            steps.append(ffm)
    if len(steps) == 0:
        return [1]

    return steps
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Results} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hl {przeniesc legende? JAKO OSOBNY PDF? i podac w tej sekcji - tak sie nie robi
ale bylo by ok i czytelnie + wiecej miejsca na wykresy a przypadkow bedzie
wiecej}
\hl{czy wykres loss oraz score dla przypadkow powinnien byc nalozony? albo
polaczony subfigurem tak aby osie byly sync. i dalo sie porownac}

performance plot\footnote{wykres zostal zrobiony poprzez posortowanie scorow - dzieki temu widac roznice w
przyroscie i latwo dostrzec ktory algorytm ma najwyzszy score lub jaka ma
chaktersytyke (np. jest bardzo skuteczny dla waskiej grupy przykladow)
}

\hl{\textbf{UWAGE}: usunac z tabelek PODOBNE ALGORYTMY i ich slabsze rezultaty}

\begin{table}[H] \centering
\begin{tabular}{@{}l|ccc@{}}
\toprule
\hspace*{0.175cm}\diagbox{\textbf{Density}}{\textbf{Shape}}
                         & Small (32-128)    & Medium (256-448)   & Large (512-1536)  \\
\midrule
Low ($\rho$=0.00005-0.001)    & JFA           & Blabla        & ?       \\
High ($\rho$=0.01-0.1)        & JFAStar           & ?        & ?       \\
\bottomrule
\end{tabular}
\vspace{1em}
\caption{Found in this paper state-of-the-art for specific domains.}
\end{table}

\subsection{Multi-domain Algorithm (\ourjfasingle)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
	\item \textbf{shapes}: \{32x32, 64x64, 96x96, 128x128, 256x256, 320x320, 384x384, 448x448, 512x512, 768x768, 1024x1024, 1536x1536\}
	\item \textbf{cases}:
        \begin{itemize}
			\item gen\_uniform: seeds=1,
			\item gen\_uniform: seeds=3,
			\item gen\_uniform: density=0.0001,
			\item gen\_uniform: density=0.001,
			\item gen\_uniform: density=0.01,
			\item gen\_uniform: density=0.02,
			\item gen\_uniform: density=0.03,
			\item gen\_uniform: density=0.04,
			\item gen\_uniform: density=0.05,
			\item gen\_uniform: density=0.1,
		\end{itemize}
\end{itemize}

\begin{figure}[H]
	\centering
	% \includegraphics[width=\linewidth]{../figures/figure-1-time}
	\includegraphics[width=\linewidth]{../figures/figure-2-loss}
	\includegraphics[width=\linewidth]{../figures/figure-3-score}

	% not needed for single domain?
	\includegraphics[width=\linewidth]{../figures/figure-4-power}
	\caption{bla bla bla}
	\label{fig:abstract}
\end{figure}

\begin{table}[H]
	\centering
	%\hspace*{-1cm}
	\input{../figures/table.tex}
	\newline
	\caption{domain: 32x32, 64x64, 128x128, 256x256}
\end{table}

\subsection{Specific-domain Algorithm} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Small Shape: 32x32, 64x64, 96x96, 128x128}

\longvar{Square-Special(1.44/0.96/0.17/1.63/0.86)+Noise}
\newline
and\hfill \longvar{Square-Special(1.07/0.24/0.9/1.88/0.64)}

\begin{figure}[H]
	\begin{minipage}{0.48\textwidth}
		\centering
		\includegraphics[height=4.5cm]{../figures/results-small-low/legend}
		\includegraphics[width=1\linewidth]{../figures/results-small-low/figure-2-loss}
		\includegraphics[width=1\linewidth]{../figures/results-small-low/figure-3-score}
		\caption{Low Density}
		\label{Fig:noise}
	\end{minipage}\hfill
	\begin{minipage}{0.48\textwidth}
		\centering
		\includegraphics[height=4.5cm]{../figures/results-small-high/legend}
		\includegraphics[width=1\linewidth]{../figures/results-small-high/figure-2-loss}
		\includegraphics[width=1\linewidth]{../figures/results-small-high/figure-3-score}
		\caption{High Density}
		\label{Fig:lnoise}
	\end{minipage}
\end{figure}

\subsubsection{Medium Shape: 256x256, 320x320, 384x384, 448x448}
\subsubsection{Large Shape: 512x512, 768x768, 1024x1024, 1536x1536}

\subsubsection{Low Density}
\subsubsection{High Density}

%\subsubsection{32x32, 64x64, 96x96, 128x128}
%\subsubsection{256x256, 320x320, 384x384, 448x448}
%\subsubsection{512x512, 768x768, 1024x1024, 1536x1536}
%\subsubsection{Low Density}
%\subsubsection{High Density}

\subsection{Ensemble Across Domains (\ourjfa)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

bla bla

\subsection{Objectives} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hl{naprawic generowanie tego wykresu}
\hl{napisac co nie moze byc uzyte z czym?}

czyli co ma wplyw na co (w sumie to najwazniejsze mialo byc w pracy)

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{../figures/raport}
	\caption{bla bla bla}
	\label{fig:abstract}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Practical Usage} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hl{polaczyc z Conclusions}

Jest wiele projektow ktore potrzebuje DT lub voronoi-a. Jedyne dwa praktyczne
przyklady z tej pracy to SOTA dla JFA - czyli JFAstar, oraz praktyczny Ensemble
(uwzgledniajacy np. bruteforce dla malych instancji).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This paper presents the GPU's effective, almost constant, algorithm for calculating the Euclidean distance transform (DT) approximation for 2D and higher dimensional images.
%
As mentioned in \cite{cao2010parallel}, it remains challenging to balance the workload in such an approach.
%
\textit{\ourjfa} does not explicitly solve this issue but, by constructing an alternative solution utilizing random shortcuts and parameter estimation, it makes it a reasonable approximation.
%
In practice, such a constant time algorithm is useful in many interactive applications, such as tessellations, rendering, and image processing, involving \cite{rong2006jump}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Acknowledgements} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hl{Dziekuje swojemu psu!Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu! Dziekuje swojemu psu!  }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\printbibliography
\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

\end{document}
